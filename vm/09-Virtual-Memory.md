# 9 Virtual Memory

介绍虚拟内存之前，需要阐述的核心概念是**虚拟化**。虚拟化在计算机科学中是一个非常重要的概念。本质上，虚拟化是一种将物理资源转化为逻辑资源的一种**抽象**。

虚拟化一个资源时，需要向不同用户呈现不同的视图，通常可以通过干预和介入对该资源的访问来实现。

磁盘访问中使用了虚拟化技术。磁盘控制器是此破案的虚拟化视图，将磁盘抽象成一系列的逻辑块提供给内核；它通过拦截来自内核的读写请求来呈现该视图，并将内核发送的逻辑块号转换为物理块号。

因此，下面这一章将围绕虚拟化思想，对主存储器进行虚拟化，得到扩充的主存储器，也就是虚拟内存。



## 9.1 物理地址和虚拟地址

CPU对主存储器的访问通过**内存管理单元**（MMU）的硬件来实现。MMU能够将CPU提供的虚拟地址转换为物理地址，从而实现对实际内存物理的资源的访问控制。



## 9.3 虚拟内存作为缓冲工具

DRAM可以看做是硬盘的缓存。虚拟内存可以看成存储在磁盘上的一系列连续字节数组。

磁盘被分成若干固定大小的**块**，成为**虚拟页**；同时，物理内存也被划分成若干相同大小的页。虚拟内存中的页有如下状态：
- 未分配：不占据磁盘空间
- 缓存：分配目前缓存在物理内存中的页
- 未缓存：分配目前尚未换存在物理内存中的页

### 9.3.1 DRAM缓存组织

- 缓冲主要使用SRAM，速度至少是DRAM的10倍
- 主存主要适用DRAM，访问速度是磁盘的大约100,000倍，因此未命中的惩罚很高
- 同时，虚拟内存中磁盘和主存是全相关联的，这样就可以采取更好的替换算法提高平均访问速度。

### 9.3.2 页表

虚拟内存系统需要了解当前缓存在DRAM中的页的信息，当出现未命中时采取页面替换算法选取换出页进行替换。这样的能力是由操作系统团建，MMU中的地址转换硬件和物理内存中的数据结构**页表**来实现。

页表主要负责虚拟地址到物理地址的映射。地址转换硬件通过访问特表进行地址转换，操作系统则负责维护页表并在DRAM和磁盘之间来回传输页。

页表由一系列的页表项构成，每个页表项包含一个**有效位**和`n`位的地址字段。有效位用于标记虚拟页是否存储在DRAM中；`n`位地址字段则表示：
- 空指针`NULL`：未分配
- 有效位置位：DRAM中对应物理页的起始地址
- 有效位复位：虚拟页在磁盘中的起始地址

### 9.3.3 页命中

访问页表，如果页表的有效位为`1`，则该页表换存在DRAM中，通过地址指针访问，此时成为**页命中**。

### 9.3.4 缺页错误

访问页表，如果页表有效位为`0`，表示没有缓存在DRAM中，此时硬件将会产生**缺页异常**，控制权交给内核后，操作系统选择一个牺牲页，换出主存，将所需页面调入主存对应位置。

由于程序的局部性，程序倾向于访问被称为**工作集**的页面，也就是最近经常访问的页面。如果工作集小于主存大小，则虚拟内存可以表现出很好的性能。但是如果虚拟内存超过出脆，进程将会出现**颠簸**(*thrashing*)的现象。



## 9.4 虚拟内存作为内存管理工具

虚拟内存作为内存管理工具的核心思想是：**每一个进程都有自己的虚拟地址空间**。每一个进程的虚拟页面可以映射到DRAM的任何位置。通过这种方式，可以为每一个程序员和工具提供一个视图，程序猿认为每个进程都有自己的虚拟地址空间，但实质上存储在内存的不同位置。

- 简化链接过程。虚拟内存为每一个进程的地址空间提供类似的格式。链接器可以将各个模块链接起来，形成进程空间中完整的程序，和实际存储相独立。
- 简化加载过程。数据和代码只分配不缓存。数据在需要（缺页）时动态装载到DRAM中。将连续的虚拟页映射到文件任意位置的技术被称为**内存映射**(*Memory Mapping*)。
- 简化共享。通过将不同进程的虚拟页映射到相同的物理页，可以在物理内存中只保留一份代码拷贝，例如内核代码。
- 简化内存分配。分配内存时，不需要为连续的虚拟页分配连续的物理页，这些物理页可以随机分散在物理内存的任意位置。



## 9.5 虚拟内存作为内存保护工具

Intel x86-64芯片规定，高位为`1`的地址都是内核的代码或数据。

虚拟内存作为内存保护工具，可以提供如下功能：
- 用**权限位**扩展页表项（管理员、读、写、执行）
- 每次访问MMU都检查相关权限



## 9.6 地址翻译 

- 虚拟地址空间：$V=\{0, 1, \cdots,\ N-1\}$
- 物理地址空间：$P=\{0,1,\cdots,M-1\}$

地址翻译实质上是一个 $VAS$ 到 $PAS$ 集合的映射：
$$
MAP:\ VAS \rightarrow PAS\ \cup \empty
$$
对于虚拟地址 $a$：

- $MAP(a)=a'$：虚拟地址存储在物理地址 $a'$ 的位置
- $MAP(a)=\empty$：虚拟地址不在物理内存中（无效或存储在磁盘上）



### 9.6.1 地址翻译的步骤

页表的开头由**页表基地址寄存器**(*Page Table Base Register*)指向。地址翻译由以下步骤构成：

1. 处理器生成虚拟地址并送往MMU
2. MMU（解析虚拟地址后）生成PTE地址并向主存/缓存请求
3. 主存/缓存（根据PTBR和VPN）返回PTE给MMU
4. MMU构建物理地址（PPN+PPO）并发送给主存/缓存
5. 主存/缓存将被请求的字返回给处理器

如果出现缺页中断，则步骤如下：

1-3. 和上述步骤一致

4. PTE有效位为`0`，MMU出发异常，将控制权交给CPU，执行内核的缺页异常处理程序
5. 处理程序在主存中确认牺牲页。如果该页被修改，则需要写回磁盘。
6. 处理程序将新页调入并更新PTE
7. 处理程序返回到被中断指令重新执行



### 9.6.2 使用TLB加速翻译

**TLB** (*Translation lookaside Buffer*) 是一个小的虚拟地址缓存。虚拟地址在TLB中有如下字段

![CSE 351 Section 8 – Virtual Memory](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSRscO41JTlV1M5W4ked74ZA2MtO3yQO5DWD5CrN3nwUMnSQlBnn0QBjX_Ie9yEr__3bA&usqp=CAU)

TLB的每一行为一个集合，包含拥有相同`TLBI`的PTE。查找TLB时，根据虚拟地址解析出`TLBI`，之后查找集合中是否包含`TLBT`项，如果有，表示命中，返回对应PTE，否则命中失败，重新查找缓存/主存中的页表。



### 9.6.3 多级页表

对于一个64bit的操作系统，如果页表大小为4KB，8B的PTE，那么页表大小将会达到512GB，这显然是无法接受的。解决这个问题的方案就是时就用页表的层次结构。

例如在两级页表中，1级页表的PTE存储2级页表起始地址。通过多级页表可以避免空间的浪费。

多级页表的地址翻译：将页表地址划分为若干字段，用每个字段查找对应页表的PTE，找到下一个页表的起始地址，最后通过偏移定位要访问的数据。



## 9.7 样例：Intel Core i7/Linux 内存系统

在Core i7内存系统中，存在两个很有意思的现象：

1. `i-TLB`的条目比`d-TLB`更多
2. 存在`L2 unified TLB`

第一个现象可能是由于对指令的TLB惩罚比对数据的TBL更高。而第二个现象则是为了平衡访问的速度和命中率，因为不同的程序指令集和数据集大小关系是不确定的，通过增加第二级缓存可以**减少不命中的惩罚**。

### 9.7.1 Core i7 地址翻译

Core i7的虚拟内存地址为64位，不同的TLB条目被划分为不同的字段。其中L1，L2和L3字段相同，而L4的字段则不同（需要**引用位**和**脏位**两个字段，不需要页长字段）。除此以外，设立了不同的权限字段。

同时Core i7也采取策略加速L1访问。由于VPO和PPO是完全相同的，当MMU获取虚拟地址后，可以将虚拟地址VPO送入L1。由于VPO可以解析出CI和CO，因此可以找到CT不同的一系列数据。如果L1命中，且MMU得到PPN(=CT)，则直接在更少的候选数据之中匹配即可。

### 9.7.2 Linux 虚拟内存系统

内核在进程的虚拟地址空间中，且每一个进程所看到的内核代码和数据、物理内存都是相同的。内核将连续的虚拟页面映射到一组连续的物理页面，提供了内核方便访问物理内存的方法。

<img src="https://i.stack.imgur.com/R4tVn.png" alt="enter image description here"  />

#### Linux 虚拟内存段

Linux内核将页面组织称一系列的**段** (*segment*) ，例如代码段、数据段、堆、共享库段等。这些段都是相关连续的虚拟页构成的。内核包含一系列数据结构如下：

- 内核为每一个进程维护一个独一无二的数据结构`task_struct`，其中包含了内核运行进程所需的所有信息的数据或指针。其中有一个字段为`mm`，指向数据结构`mm_struct`。
- `mm_struct`指示虚拟内存目前的状态。其中最重要的字段为：`pgd`，指向一级页表；`mmap`，指向一个`vm_area_struct`链表。
- `vm_area_struct`指示了目前虚拟地址空间中的一个段。其中包含了每一段的起始地址、结束地址、权限、共享、下一节点有关信息。

<img src="https://i.stack.imgur.com/QU2ye.png" alt="enter image description here"  />

#### Linux 页面中断异常处理

Linux在处理缺页错误时需要经过如下步骤：

1. 检查虚拟地址 $A$ 是否合法。处理程序将会判断地址 $A$ 是否包含在`vm_area_struct`链表中某一个段的范围内。如果地址不合法将会引发错误`Segmentation Fault`，之后终止该进程。为了加速这一过程，Linux在链表上会叠加一棵树，在树上进行搜索。
2. 检查访问是否合法。如果对一个只读页进行了写操作或用户态进程试图读取内核虚拟内存中的字，出炉程序将会触发`Protection Exception`，进程将会终止。
3. 正常的缺页中断。



## 9.8 内存映射

虚拟内存区域初始化的时候和磁盘上的对象关联起来，这个过程就叫做**内存映射** (*Memory Mapping*) 。每个段都可以用设为两种对象：

1. Linux系统上的**普通文件**。一个段可以映射为连续的普通磁盘文件区域，初始的内容来自于那个文件。例如，代码区和可执行二进制文件。
2. **匿名文件**。由Linux内核创建，大小不限，内容全部为二进制`0`。也被称为**二进制全零请求页** (*demand-zero pages*)。对该文件的交换实质上不在内存和磁盘间交换任何数据。

### 9.8.1 共享对象重访

可以被共享的对象被称为**共享对象**，否则是**私有对象**。当一个进程将共享对象映射到它的虚拟内存中后，该共享对象也会被其他的进程映射到对应的虚拟内存。

由于每一个对象都有独特的文件名，因此内核可以迅速判断进程是否已经映射共享文件到物理内存，之后将其指向其他进程的页表项。

但是，有一部分页面是共享**私有对象**，采取**写时复制**策略。映射私有对象的进程，其相关段被标记为`private copy-on-write`。当其他进程试图修改这些页面时，将会触发`protection fault`。处理程序会创建一个页面副本，修改副本的数据，并将修改进程的页表相关PTE指向该副本。

### 9.8.2 `fork`函数重访

`fork`函数实质上就是采取写时复制的策略，让每个进程进程空间中拥有独立的视图。（妙）

### 9.8.3 `execve`函数重访

当前进程如果调用`execve`函数：

```c
execve("a.out", NULL, NULL);
```

则表示在当前进程中加载并运行包含在可执行目标文件`a.out`的程序。该过程分为如下步骤：

1. 删除现有用户段。删除当前进程虚拟地址原有的`area struct`数据结构。
2. 映射私有段。为新的代码、数据、`.bss`和堆栈段创建写时复制的`area struct`。代码段和数据段被映射到`a.out`的`.text`和`.data`段；`.bss`段则映射到匿名文件，大小包含在`a.out`中；堆栈段也映射到匿名文件，初始大小为`0`。
3. 映射共享段。动态链接文件，例如C标准库`libc.so`，到用户段虚拟地址空间。
4. 设置程序计数器`PC`，指向程序的入口。

### 9.8.4 用户级内存映射：`mmap`函数



## 9.9 动态内存分配

程序在**运行时**使用**动态内存分配器** (*dynamic memory allocator*) 来获取虚拟地址。动态内存管理器维护了被称为**堆**的进程虚拟内存区域。

不同系统间的对存在差异，但是都具备以下特点：

1. 初始化时数据均为`0`；
2. 向上增长；
3. 对于每个进程，内核维护堆顶指针`brk`。

分配器将内存非为连续的块（大小各异）的集合。块存在**分配**和**空闲**两种状态。在C语言中，使用显式的分配器`mallc`和`free`来操作内存。对于Java，存在垃圾回收器等隐式分配器。

### 9.9.1 `malloc`和`free`函数

#### 1. `malloc`函数

```c
#include <stdlib.h>

void* malloc(size_t size);
```

- 如果函数运行成功，则返回内存块的指针，和操作系统的位数相对齐
- 如果不成功则返回空指针`NULL`，并设置`errno`

#### 2. `free`函数

```c
#include <stdlib.h>

void free(void *ptr);
```

- 参数必须为`malloc`或者`realloc	`返回的指针

### 9.9.2 为什么使用动态内存分配

在程序运行之前，我们并不清楚确定数据结构的大小，因此我们需要一种动态的策略，根据实际需求进行动态内存分配，而不是采用**硬编码**事先规定大小。

### 9.9.3 分配器需求和目标

#### 1. 分配器存在的限制

- 需要处理任意的需求序列
- 对请求立即响应
- 仅使用堆存储
- 对齐块
- 不修改已分配的块

#### 2. 性能目标

分配器包含了时间和空间上的权衡。我们期望尽可能快，同时尽可能高效使用堆中的虚拟内存。

给定义`malloc`和`free`的请求序列：
$$
R_0,\ R_1,\ \cdots,\ R_k,\ \cdots,\ R_{n-1}
$$
目标：最大化**吞吐量**和**内存利用率**。我们定义一个**有效载荷** (*payload*) 的概念，指的是应用请求分配后实际分配的字节数。我们定义内存利用率为：
$$
U_k=\frac{\max_{i\le k} P_i}{H_k}
$$
其中 $H_k$ 表示当前堆的大小，$P_i$ 表示聚合有效载荷。

### 9.9.4 碎片 (*Fragmentation*)

对于一个给定的快，有效负荷小于块大小时，出现**内部碎片**。由于内部碎片取决于之前请求的模式，因此可以在某个时间点确定内部碎片的级别。

堆中有足够的内存，但没有一个可以满足特定请求的块时，就出现了**外部碎片**。外部碎片取决于未来的请求模式，因此更加难以处理。

### 9.9.5 实现问题

- 空闲块管理：如何跟踪空闲块
- 替换：如何选取合适的空闲块来存放刚被分配的块
- 分裂：替换之后如何处理剩余的空闲块
- 合并：如何处理刚刚释放的空闲块

### 9.9.6 隐式空闲链表

使用链表来组织空闲块时，最核心的就是数据结构的定义。我们需要存储块的大小和分配的状态。如果食用两个字来存储，则对空间的利用率将会下降。

标准的做法是，由于块是对齐的，一些低位地址bit总是`0`，因此可以用来存储分配/空闲状态。当读取块大小字段时，要进行掩码处理。数据结构如下：

![Solved Determine the block sizes and header values that | Chegg.com](https://media.cheggcdn.com/media/c1b/c1bf3744-70b3-4e7b-b0fb-ffe240e9a50b/phpfz7qNs)

有效负荷总是从`8`字节边界开始。分配时，需要遵循：

1. 字节对齐。分配器需要保证字节对齐，例如双字对齐时，需要确保一块的字节数是`8`的整数倍。
2. 块的大小被进位到最近的`8`的整数倍。

### 9.9.7 寻找空闲块

通常有首次适配、下次适配和最佳适配三种方法。其中下次适配使用时间换空间，权衡时空的好方法。

首次适配算法的C语言代码如下：

```c
void *p = start;
while ((p < end) &&		// not passed end
       ((*p & 1) ||		// already allocated
       (*p <= len)))	// too small
  p = p + (*p & -2);	// goto next block (word addressed)
```

### 9.9.8 分配空闲块

当空闲块大于我们需要的空间时，必须要将空闲块分割以填充分配的内存。算法如下：

```c
void add_block(ptr p, int len) {
  int newsize = ((len + 1) >> 1) << 1;	// round up to event size
  int oldsize = *p & 2;									// mask out low bit
  *p = newsize | 1;											// set new length
  if (newsize < oldsize)								
    *(p+newsize) = oldsize - newsize;		// srt length in remain part of the list
}
```

### 9.9.9 释放空闲块

当释放空闲块后，可能会出现多个连续的空闲块。如果不进行合并，则会影响存储的效率。因此，我们使用如下算法的进行合并。

```c
void free_block(ptr p) {
  *p = *p & -2;						// clear allocated block
  next = p + *p;					// find next block
  if ((*next & 1) == 0)
    *p = *p + *next;			// add to this block if 
}													//		not allocated
```

上述方法的思想是检查下一块，如果空闲则进行合并。然而，这样的想法会导致一个问题：前一个空闲块将被忽略。一个可能的想法是遍历堆，但是这样会使得`free()`的效率和堆大小呈线性关系。因此我们使用Don Knuth提出的**边界标签**。

边界标签的核心思想是在块的尾部添加一个和头部完全相同的边界标签，使得可以进行类似于回溯的操作。链表被改造为双向链表。

注意到，只有空闲块才需要边界标签，因此分配块可以去掉。此时，需要额外的1bit来表示上一块是否空闲。由于存在边界对齐，总是可以找到这样的空闲位来存储。

### 9.9.10 实现简单的分配器

#### 1. 一般分配器的设计

要实现一个堆，最核心的是对已分配块和未分配块的管理，可以采用如下方法：

1. 隐式空闲链表：将所有的块相链接
2. 显式空闲链表：只在空闲块之间使用指针
3. 隔离空闲表：对不同大小的块使用不同的空闲表
4. 大小排序的空闲表：使用红黑树

#### 2. 显式空闲表

显式空闲表的实现中，每一个块都需要头部、脚步、前指针和后指针，这部分开销是不可避免的。

当使用`malloc`进行分配时，被分配块的前后空闲区的指针都将发生变化。 如果需要使用`free`释放空闲块，存在两种策略：

1. LIFO策略：简单，常数时间完成，但是可能会导致 **碎片化**
1. 按大小排序：需要进行搜索，但是碎片化比较LIFO较轻

 