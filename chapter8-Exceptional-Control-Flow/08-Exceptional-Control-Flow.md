# 8 Exceptional Control Flow
异常事件流出现在计算机系统的各个层面：
- 低级机制
  - Exception（异常）
    - 系统事件导致控制流变化（例如系统状态的改变）
    - 由硬件和OS共同实现
- 高级机制
  - Process Context Switch（进程上下文切换）
  - Signals（信号）
    - 由OS实现
  - Nonlocal jumps（非本地跳转）
    - `setjmp()`和`longjmp`

# 8.1 Exceptions
## 8.1.1 异常处理机制
- 异常实质上是将低级别的控制权转移到操作系统内核（驻留在内存的部分）
- 异常处理结束后，将会发生三种结果
  1. 控制器将控制权返回给当前指令`I_curr`
  2. 控制器将控制钱返回给下一条指令`I_next`
  3. 控制器舍弃被中断的程序

### 8.2.1 异常表
- 异常表存储各类异常处理器代码的地址，通过异常号`n`查询异常处理代码其实地址，执行相关代码

## 8.2 异常类型
1. **异步异常/中断**：处理器外部发生变化导致
  - 通过在处理器上设置引脚，向处理器通知来实现（中断引脚）
  - 控制钱返回控制权给下一条指令
  - 例如：计时器中断（每隔几毫秒执行一次）、外部设备的I/O
2. **同步异常**
   - **Trap（陷阱）**：程序故意引发的异常
     - 进行**系统调用**，从内核请求各种功能
     - 返回控制给`I_next`
   - **Fault（故障）**：程序无意引发的异常，可能可以恢复
     - 例如虚拟内存中的**页缺失**
     - 返回控制给`I_fault`
   - **Abort（中止）**：程序无意引发且**不可恢复**的异常
     - 中止程序运行

### 8.1.3 Linux/x86-64系统异常
在Linux/x86-64系统中，每一个系统调用都有一个唯一的**编号**，且Linux系统提供了相应的系统调用函数。
- `read()`：读文件
- `fork()`：创建进程

## 8.2 Process（进程）
进程的**定义**就是正在运行的文件。进程提供了两个重要的**抽象**：
1. 进程认为自己独占CPU和寄存器
2. 进程认为自己有自己的地址空间

当异常出现后，操作系统将当前进程的**寄存器**和**地址空间**复制到存储器中并存储起来；之后，操作系统安排下一次要执行的进程，将该进程寄存器保存的值从存储器复制到寄存器，同时切换到该进程的地址空间。这一过程就是**上下文切换**，也就是寄存器和地址空间的切换。

## 8.3 系统调用错误处理
出现错误时，Linux系统级函数通常会返回`-1`并将全局变量`errno`设置为对应错误码。

```c
void unix_error(char *msg) {
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}

pid_t Fork() {
    pid_t pid;

    if ((pid = fork()) < 0)
        unix_error("Fork error");
    return pid;
}
```

## 8.4 进程控制
### 8.4.1 进程状态
进程的三种状态：
1. Running（运行）：正在运行或等待被执行并最终会被内核调度
2. Stopped（停止）：进程被挂起，在进一步通知之前不会被调度
3. Terminated（中止）：进程被永久停止

### 8.4.2 进程的创建和中止
进程被终止的原因如下：
1. 接收到默认行为是中止的信号
2. 从`main`函数返回
3. 调用`exit`函数

进程创建和中止常常使用如下函数：
1. `void exit(int status)`
   - 功能：退出进程
   - 只被调用一次且不返回任何值
2. `int fork()`
   - 功能：创建子进程
   - 被调用一次，但是返回两次
   - 子进程返回值为`0`，父进程返回值为子进程的`PID`
   - 除了`PID`之外，子进程和父进程拥有相同的**虚拟地址空间**和**打开文件描述符**

### 8.4.3 子进程回收
子进程中之后，仍然占用一部分操作系统资源，例如**退出状态**、**各种OS表**等，此时该子进程被称为**僵尸进程**。僵尸进程需要等待父进程回收。父进程回收子进程，获得退出状态信息后，内核删除僵尸进程。

如果父进程没有回收子进程且父进程中止，则系统安排`PID=`的第一个进程`init()`回收子进程，这样的子进程也被称为**孤儿进程**。

如果不及时回收子进程，将会导致内存泄漏（memory leak）。因此，必须使用`wait()`或者`waitpid()`函数回收僵尸进程。

