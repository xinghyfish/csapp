# 10 系统级I/O
## 10.1 Unix I/O

Linux系统下的文件可以抽象为`m`个比特的序列：
$$
B_0,\ B_1,\ \cdots,\ B_k,\ \cdots,\ B_{m-1}
$$
一个很有趣的事实是，所有的I/O设备都被表示成文件：

- `/dev/sda2`：`/user` disk partition
- `/dev/tty2`：终端

甚至内核也可以表示为文件。

文件系统用一个**当前文件指针**来表示下一个文件读写的偏移的位置。

## 10.2 文件

每个文件在系统中都有一种类型。例如：

- **普通文件**：存储任意的数据
    - **文本文件**：只包含ASCII或Unicode编码字符
    - **二进制文件**：字节序列式以某种形式编码的
- **目录**：相关的一组文件的索引
- **Socket**：发送和接受网络消息

还有一些文件类型（命名管道、符号连接、字符和块设备）不进行讨论。



## 10.3 打开和关闭文件

- **文件描述符**：一个小整数，标识当前程序正在操作某个打开的文件，按照打开的顺序进行编号。

```c
int fd;		/* file descriptor */
if ((fd = open("/etc/hosts", O_RDONLY)) < 0) {
    perror("open");
    exit(1);
}
```

`open()`函数的返回值是文件描述符，如果是`-1`则表示出现了错误。

注意到，每个运行的进程都有三个特定的文件描述符：

- `0`：标准输入`stdin`
- `1`：标准输出`stdout`
- `2`：标准错误`stderr`

关闭文件时买只需要指定文件描述符即可：

```c
int fd;			/* file descriptor */
int retval;	/* return value */
if ((retval = close(fd)) < 0) {
    perror("close");
    exit(1);
}
```

再多线程编程时，两个线程同时尝试关闭同一个共享的文件时，可能会引发错误。



## 10.4 读写文件

在进行文件的读取操作时，`read()`函数至多从文件描述符`fd`中拷贝`n`个字节到内存区`buf`中。注意到，函数的格式为：

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t n);
```

该函数的返回值为实际读取的字节数，如果是`EOF`返回`0`，如果出现错误则返回`-1`。需要注意的是，一定要指定**缓冲区的长度**，避免发生溢出。

在读写文件时，会出现**不足值**(*short counts*)，这并不是一种错误，而是读写实际传输的字节数比请求的字节数更少的现象，由以下原因导致：

1. 读文件遇到`EOF`：截断读取
2. 在终端读取文本行
3. 读写网络`socket`：内部缓冲和网络延迟导致



## 10.5 健壮读写`RIO`

- 非缓冲输入输出函数
  - 直接在内存和文件之间传输
- 带缓冲输入输出函数
  - 线程安全
  - 可以传输任意类型的数据

### 10.5.1 非缓冲输入输出函数

改方案通过循环来处理不足值的情况。读文件时，除非遇到`EOF`，否则不会出现不足值的情况；写文件不会遇到不足值。

### 10.5.2 带缓冲输入输出

带缓冲输入输出函数分为两种：1. 基于文本；2. 基于字节。

在该方案中，每一个文件都有一个缓冲区相关联。当需要读取时，调用一定的字节存入缓冲区，后续的读取只需要从缓冲区读取即可，而不需要进行额外的系统调用。

## 10.6 读取文件元数据

通过数据结构`stat`和`stat()`函数可以获取文件元数据信息。

## 10.7 读取目录内容

## 10.8 共享文件

Linux系统中，文件共享存在多种形式，例如：
1. 描述符表：每个进程拥有一个描述符表，每个表项为指向对应文件表表项的索引
2. 文件表：由当前文件位置、引用数、`v-node`指针组成
3. `v-node`表：包含`stat`的大部分信息

上述三种存储形式并不是孤立存在的，而是针对不同层面的访问采用不同的视图。其关系为：描述符表==>文件表==>`v-node`表。对于进程而言，其拥有的只是描述符表；而内核拥有对应的文件表，控制具体的打开文件信息；`v-node`表则存储文件自身相关的数据。

当使用`fork`函数创建子进程时，子进程将会创建父进程的描述符表的**拷贝**；但是，父进程将和子进程共享相同的文件表。这就意味着，二者的当前文件位置指针相同，且调用`fork()`函数后，对应文件表的引用数量将会增加。

需要注意的是，父进程和子进程在内核删除对应文件表项之前都要使用`close()`关闭文件。

## 10.9 I/O重定向

在shell中，可以使用I/O重定向将输出重定向到磁盘文件，例如在shell中使用指令：
```shell
ls > foo.txt
```
上述指令调用`ls`程序，其输出将被重定向至文件`foo.txt`中。

在C语言中，可以使用函数：
```c
#include <unistd.h>

int dup2(int oldfd, int newfd);
```
上述函数将`oldfd`的描述符表项拷贝到`newfd`的描述符表项中，也就是说`newfd`将会被更改。如果`newfd`已经打开，则在拷贝前将其关闭。shell的例子中就是将标准输出从shell重定向至`foo.txt`文件。

如果重定向至已有的文件，原文件描述符对应的打开文件表将会更新，如图10.15.

## 10.10 标准I/O

标准I/O库就是著名的`<stdio.h>`库。其中包含了标准输入、标准输出和标准错误。所采用的数据结构为`FILE`，该数据结构是文件描述符和**流缓冲**(*stream buffer*)的抽象。引入缓冲的目的是减少系统调用次数，类似于`RIO`中的缓冲策略。

## 10.11 I/O整合和策略选取

关于具体实现时I/O函数的选取，通常有以下准则：
1. 尽可能使用标准I/O函数（除非是`stat()`）
2. 不要在读取二进制文件时使用`scanf()`或`rio_readlineb()`函数（专用于文本文件）
3. 在网络socket中使用RIO函数

输入输出流也存在一定的限制：
1. 当输出后需要输入时，需要调用`fflush()`清空和流相关的缓冲区；或者调用`fseek()`、`fsetpos()`、`rewind()`重置文件描述符。
2. 当输入后需要输出时，除非遇到`EOF`，则需要调用`fseek()`、`fsetpos()`、`rewind()`重置文件描述符。

当处理网络I/O时，上述的第二个限制只能通过调用两次`open()`函数，即同时使用两个文件描述符分别进行输入输出来解决。此时，必须调用`close()`来关闭流以释放和流相关的内存空间，避免内存泄漏。

```c
FILE *fpin, *fpout;

fpin = fdopen(sockfd, "r");
fpout = fdopen(sockfd, "w);

// some operations...

fclose(fpin);
fclose(fpout);
```

但是，上述方案将会重复关闭同一个流，将会引发错误。因此，推荐使用RIO函数。
- 如果需要格式化输出，使用`sprintf`在内存中格式化字符串，之后使用`rio_written`送到socket；
- 如果需要格式化输入，使用`rio_readlineb`读取一整行文本，之后使用`sscanf`提取字符串不同的字段。

